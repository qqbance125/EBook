package com.qihoo360.reader.ui.channels;import android.content.Context;import android.util.AttributeSet;import android.view.MotionEvent;import android.view.VelocityTracker;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.widget.Scroller;public class ScrollLayout extends ViewGroup {    public static boolean startTouch = true;    private Scroller mScroller;    /*     * 速度追踪器，主要是为了�?过当前滑动�?度判断当前滑动是否为fling     */    private VelocityTracker mVelocityTracker;    /*     * 记录当前屏幕下标，取值范围是�? �?getChildCount()-1     */    private static int mCurScreen;    private int mDefaultScreen = 0;    private static int mPreScreen = mCurScreen;    /**     * 初始化后默认显示的那个屏幕号     * @param defaultScreen     */    public void setDefaultScreen(int defaultScreen) {        this.mDefaultScreen = defaultScreen;    }    /*     * Touch状�?�?0：静�?1：滑�?     */    private static final int TOUCH_STATE_REST = 0;    private static final int TOUCH_STATE_SCROLLING = 1;    /*     * 记录当前touch事件状�?--滑动（TOUCH_STATE_SCROLLING）�?静止（TOUCH_STATE_REST 默认�?     */    private int mTouchState = TOUCH_STATE_REST;    private static final int SNAP_VELOCITY = 600;    /*     * 记录touch事件中被认为是滑动事件前的最大可滑动距离     */    private int mTouchSlop;    /*     * 记录滑动时上次手指所处的位置     */    private float mLastMotionX;    private float mLastMotionY;    private OnScrollToScreen onScrollToScreen = null;    public ScrollLayout(Context context, AttributeSet attrs) {        this(context, attrs, 0);        // TODO Auto-generated constructor stub    }    public ScrollLayout(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        // TODO Auto-generated constructor stub        mScroller = new Scroller(context);        mCurScreen = mDefaultScreen;        mPreScreen = mDefaultScreen;        mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();    }    @Override    protected void onLayout(boolean changed, int l, int t, int r, int b) {        // TODO Auto-generated method stub        int childLeft = 0;        final int childCount = getChildCount();        for (int i = 0; i < childCount; i++) {            final View childView = getChildAt(i);            if (childView.getVisibility() != View.GONE) {                final int childWidth = childView.getMeasuredWidth();                childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight());                childLeft += childWidth;            }        }    }    @Override    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {        super.onMeasure(widthMeasureSpec, heightMeasureSpec);        final int width = MeasureSpec.getSize(widthMeasureSpec);        final int widthMode = MeasureSpec.getMode(widthMeasureSpec);        if (widthMode != MeasureSpec.EXACTLY) {            throw new IllegalStateException("ScrollLayout only canmCurScreen run at EXACTLY mode!");        }        final int heightMode = MeasureSpec.getMode(heightMeasureSpec);        if (heightMode != MeasureSpec.EXACTLY) {            throw new IllegalStateException("ScrollLayout only can run at EXACTLY mode!");        }        // The children are given the same width and height as the scrollLayout        final int count = getChildCount();        for (int i = 0; i < count; i++) {            getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);        }        scrollTo(mCurScreen * width, 0);        doScrollAction();    }    /**     * 方法名称：snapToDestination 方法描述：根据当前位置滑动到相应界面     *     * @param whichScreen     */    public void snapToDestination() {        final int screenWidth = getWidth();        final int destScreen = (getScrollX() + screenWidth / 2) / screenWidth;        snapToScreen(destScreen);    }    /**     * 方法名称：snapToScreen 方法描述：滑动到到第whichScreen（从0�?��）个界面，有过渡效果     *     * @param whichScreen     */    public int snapToScreen(int whichScreen) {        // get the valid layout page        whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));        if (getScrollX() != (whichScreen * getWidth())) {            final int delta = whichScreen * getWidth() - getScrollX();            final int duration = Math.abs(delta) * 2;            mScroller.startScroll(getScrollX(), 0, delta, 0, duration);            mPreScreen = mCurScreen;            mCurScreen = whichScreen;            doScrollAction(duration);            doSnapToScreen(whichScreen, duration);            invalidate(); // Redraw the layout            return duration;        }        return 0;    }    /**     * 方法名称：setToScreen 方法描述：指定并跳转到第whichScreen（从0�?��）个界面     *     * @param whichScreen     */    public void setToScreen(int whichScreen) {        whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));        mPreScreen = mCurScreen;        mCurScreen = whichScreen;        scrollTo(whichScreen * getWidth(), 0);        doScrollAction();    }    public int getCurScreen() {        return mCurScreen;    }    public int getPreScreen(){        return mPreScreen;    }    @Override    public void computeScroll() {        // TODO Auto-generated method stub        if (mScroller.computeScrollOffset()) {            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());            postInvalidate();        }    }    @Override    public boolean onTouchEvent(MotionEvent event) {        // TODO Auto-generated method stub        if (mVelocityTracker == null) {            mVelocityTracker = VelocityTracker.obtain();        }        mVelocityTracker.addMovement(event);        final int action = event.getAction();        final float x = event.getX();        switch (action) {        case MotionEvent.ACTION_DOWN:            if (!mScroller.isFinished()) {                mScroller.abortAnimation();                if(mOnSnapToScreenListener != null) {                    mOnSnapToScreenListener.onSnapToScreenInterrupted();                }            }            mLastMotionX = x;            break;        case MotionEvent.ACTION_MOVE:            int deltaX = (int) (mLastMotionX - x);            mLastMotionX = x;            scrollBy(deltaX, 0);            this.doContentScrollAction(deltaX);            break;        case MotionEvent.ACTION_UP:            final VelocityTracker velocityTracker = mVelocityTracker;            velocityTracker.computeCurrentVelocity(1000);            int velocityX = (int) velocityTracker.getXVelocity();            if (velocityX > SNAP_VELOCITY && mCurScreen > 0) {                // Fling enough to move left                snapToScreen(mCurScreen - 1);            } else if (velocityX < -SNAP_VELOCITY && mCurScreen < getChildCount() - 1) {                // Fling enough to move right                snapToScreen(mCurScreen + 1);            } else {                snapToDestination();            }            if (mVelocityTracker != null) {                mVelocityTracker.recycle();                mVelocityTracker = null;            }            mTouchState = TOUCH_STATE_REST;            break;        case MotionEvent.ACTION_CANCEL:            mTouchState = TOUCH_STATE_REST;            break;        }        return true;    }    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        // TODO Auto-generated method stub        final int action = ev.getAction();        if ((action == MotionEvent.ACTION_MOVE) && (mTouchState != TOUCH_STATE_REST)) {            return true;        }        final float x = ev.getX();        final float y = ev.getY();        switch (action) {        case MotionEvent.ACTION_DOWN:            mLastMotionX = x;            mLastMotionY = y;            mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;            break;        case MotionEvent.ACTION_MOVE:            final int xDiff = (int) Math.abs(mLastMotionX - x);            if (xDiff > mTouchSlop) {                if (Math.abs(mLastMotionY - y) / Math.abs(mLastMotionX - x) < 1)                    mTouchState = TOUCH_STATE_SCROLLING;            }            break;        case MotionEvent.ACTION_CANCEL:        case MotionEvent.ACTION_UP:            mTouchState = TOUCH_STATE_REST;            break;        }        return mTouchState != TOUCH_STATE_REST;    }    /**     * 方法名称：doScrollAction 方法描述：当滑动切换界面时执行相应操�?     *     * @param index     */    private void doScrollAction() {        this.doScrollAction(0);    }    private void doScrollAction(int duration) {        if (onScrollToScreen != null) {            onScrollToScreen.doAction(duration);        }    }    private void doSnapToScreen(int curScreen, int duration){        if(mOnSnapToScreenListener !=null){            mOnSnapToScreenListener.onSnapToScreen(curScreen, duration);        }    }    /**     * 方法名称：setOnScrollToScreen 方法描述：设置内部接口的实现类实�?     *     * @param index     */    public void setOnScrollToScreen(OnScrollToScreen paramOnScrollToScreen) {        onScrollToScreen = paramOnScrollToScreen;    }    /**    * 接口名称：OnScrollToScreen 接口描述：当滑动到某个界面时可以调用该接口下�?doAction()方法执行某些操作     *     * @author wader     */    public abstract interface OnScrollToScreen {        public void doAction(int duration);    }    OnContentScrollListener mOnContentScrollListener;    private void doContentScrollAction(int deltaX) {        if (mOnContentScrollListener != null) {            mOnContentScrollListener.onContentScroll(-(deltaX / getChildCount()));        }    }    public void setOnContentScrollListener(OnContentScrollListener onContentScrollListener) {        mOnContentScrollListener = onContentScrollListener;    }    private OnSnapToScreenListener mOnSnapToScreenListener;    public void setOnSnapToScreenListener(OnSnapToScreenListener onSnapToScreenListener) {        mOnSnapToScreenListener = onSnapToScreenListener;    }    public abstract interface OnContentScrollListener {        public void onContentScroll(int deltaX);    }    public abstract interface OnSnapToScreenListener {        public void onSnapToScreen(int curScreen, int duration);        public void onSnapToScreenInterrupted();    }    public boolean isScrolling() {        return !mScroller.isFinished();    }}